using UnityEngine;
using System.Collections;

namespace mnUtilities.Pathfinding
{
	public class PathfinderBase : MonoBehaviour 
	{
		/// <summary>
		/// Reference to a NavMeshAgent. If left empty, the component will automatic attach a NavMeshAgent to the GameObject.
		/// </summary>
		[Tooltip("Reference to a NavMeshAgent. If left empty, the component will automatic attach a NavMeshAgent to the GameObject.")]
		public NavMeshAgent NavAgent = null;

		/// <summary>
		/// Reference to a NavMeshObstacle component. If used, the NavMeshObstacle will be activated everytime the NavMeshAgent is currently not active
		/// to avoid getting pushed around by other NavMeshAgents.
		/// </summary>
		[Tooltip("Reference to a NavMeshObstacle component. The NavMeshObstacle will be activated everytime the NavMeshAgent is currently not active to avoid getting pushed around by other NavMeshAgents. If left empty, the component will automatic attach a NavMeshAgent to the GameObject.")]
		public NavMeshObstacle NavObstacle = null;

		public float MaxPositionDistance = 1.0f;

		public Animator AnimatorObject = null;
		public string MovementParam = string.Empty;

		public bool IsPathfinderActive
		{
			get {return m_pathfindingIsActive;}
		}

		protected Transform m_transformComponent = null;
		private bool m_pathfindingIsActive = false;
		private bool m_updateAnimationData = false;

		protected void InitializeNavAgentBase()
		{
			if(NavAgent == null)
				NavAgent = this.GetComponent<NavMeshAgent>();
			if(NavObstacle == null)
				NavObstacle = this.GetComponent<NavMeshObstacle>();
			if(m_transformComponent == null)
				m_transformComponent = this.GetComponent<Transform>();

			SetPositionOnNavMesh();
		}

		/// <summary>
		/// The method locates a valid position on the current NavMesh.
		/// The object will be automatic re-positioned on the NavMesh object.
		/// </summary>
		protected void SetPositionOnNavMesh()
		{
			NavMeshHit hit;
			if(NavMesh.SamplePosition(m_transformComponent.position, out hit, MaxPositionDistance, NavMesh.AllAreas) == true)
				m_transformComponent.position = hit.position;
		}

		public void StartPathfinder(Vector3 destination)
		{	
			if(m_pathfindingIsActive == false)
			{
				InitializeNavAgentBase();
				StartCoroutine(EnableNavMeshAgent());
				StartCoroutine(CreateDestinationPath(destination));
			}
			else
				Debug.LogWarning(this + " - Pathfinder is already active. Use UpdatePathfinder instead.");
		}

		public void StartAnimation()
		{
			m_updateAnimationData = true;
			StartCoroutine(UpdateAnimationData());
		}

		public void StopAnimation()
		{
			m_updateAnimationData = false;
		}

		public void UpdatePathfinder(Vector3 destination)
		{	
			if(m_pathfindingIsActive == true)
				StartCoroutine(CreateDestinationPath(destination));
		}

		public void StopPathfinder()
		{
			if(m_pathfindingIsActive == true)
			{
				if(NavAgent.isOnNavMesh == true)
					NavAgent.Stop();

				m_pathfindingIsActive = false;
				StartCoroutine(EnableNavMeshObstacle());
				StopAnimation();
			}
			else
				Debug.LogWarning(this + " - Pathfinder is already inactive.");
		}

		/// <summary>
		/// Updates the Animator object with data which 
		/// is generated by the component.
		/// </summary>
		private IEnumerator UpdateAnimationData()
		{
			if(NavAgent != null && AnimatorObject != null && string.Equals(MovementParam, string.Empty) == false)
			{
				while(m_pathfindingIsActive == true)
				{
					yield return new WaitForEndOfFrame();
					float animationMovementValue = 0.0f;
					if(m_updateAnimationData == true)
						animationMovementValue = NavAgent.velocity.sqrMagnitude;

					AnimatorObject.SetFloat(MovementParam, animationMovementValue);
				}
			}
		}

		private IEnumerator CreateDestinationPath(Vector3 destination)
		{
			m_pathfindingIsActive = false;
			while(m_pathfindingIsActive == false)
			{
				yield return new WaitForEndOfFrame();
				if(NavAgent.isOnNavMesh == true)
					m_pathfindingIsActive = NavAgent.SetDestination(destination);
				else
				{
					m_pathfindingIsActive = false;
					SetPositionOnNavMesh();
				}
			}

			StartAnimation();
		}

		private IEnumerator EnableNavMeshAgent()
		{
			while(NavAgent.isActiveAndEnabled == false)
			{
				yield return new WaitForEndOfFrame();
				NavObstacle.enabled = false;
				if(NavObstacle.isActiveAndEnabled == false)
					NavAgent.enabled = true;
			}
		}

		private IEnumerator EnableNavMeshObstacle()
		{
			while(NavObstacle.isActiveAndEnabled == false)
			{
				yield return new WaitForEndOfFrame();
				NavAgent.enabled = false;
				if(NavAgent.isActiveAndEnabled == false)
					NavObstacle.enabled = true;
			}
		}
	}
}
