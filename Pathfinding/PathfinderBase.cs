using UnityEngine;
using System.Collections;

namespace mnUtilities.Pathfinding
{
	public class PathfinderBase : MonoBehaviour 
	{
		/// <summary>
		/// Reference to a NavMeshAgent. If left empty, the component will automatic attach a NavMeshAgent to the GameObject.
		/// </summary>
		[Tooltip("Reference to a NavMeshAgent. If left empty, the component will automatic attach a NavMeshAgent to the GameObject.")]
		public NavMeshAgent NavAgent = null;

		/// <summary>
		/// Reference to a NavMeshObstacle component. If used, the NavMeshObstacle will be activated everytime the NavMeshAgent is currently not active
		/// to avoid getting pushed around by other NavMeshAgents.
		/// </summary>
		[Tooltip("Reference to a NavMeshObstacle component. The NavMeshObstacle will be activated everytime the NavMeshAgent is currently not active to avoid getting pushed around by other NavMeshAgents. If left empty, the component will automatic attach a NavMeshAgent to the GameObject.")]
		public NavMeshObstacle NavObstacle = null;

		/// <summary>
		/// A value which is used when postioning the object on/within the navigation map. The value is the maximum distance the object can be placed away from
		/// its original position in order to find a valid position on the navigation map.
		/// </summary>
		[Tooltip("A value which is used when postioning the object on/within the navigation map. The value is the maximum distance the object can be placed away from its original position in order to find a valid position on the navigation map.")]
		public float MaxPositionDistance = 1.0f;

		/// <summary>
		/// Reference to a optional animator object.
		/// The animator object will be updated with data from the component whenever it is active.
		/// </summary>
		[Tooltip("Reference to a optional animator object. The animator object will be updated with data from the component whenever it is active.")]
		public Animator AnimatorObject = null;

		/// <summary>
		/// Reference to a parameter string which is used to update the Animator component with the objects current movement speed.
		/// </summary>
		[Tooltip("Reference to a parameter string which is used to update the Animator component with the objects current movement speed.")]
		public string MovementParam = string.Empty;

		/// <summary>
		/// Returns a flag to determin if the pathfinder component is currently active (true) or not (false).
		/// </summary>
		public bool IsPathfinderActive
		{
			get {return m_pathfindingIsActive;}
		}

		protected Transform m_transformComponent = null;
		private bool m_pathfindingIsActive = false;
		private bool m_updateAnimationData = false;

		/// <summary>
		/// Initializes all required variables.
		/// </summary>
		protected void InitializeNavAgentBase()
		{
			if(NavAgent == null)
				NavAgent = this.GetComponent<NavMeshAgent>();
			if(NavObstacle == null)
				NavObstacle = this.GetComponent<NavMeshObstacle>();
			if(m_transformComponent == null)
				m_transformComponent = this.GetComponent<Transform>();

			SetPositionOnNavMesh();
		}

		/// <summary>
		/// The method locates a valid position on the current NavMesh.
		/// The object will be automatic re-positioned on the NavMesh object.
		/// </summary>
		protected void SetPositionOnNavMesh()
		{
			NavMeshHit hit;
			if(NavMesh.SamplePosition(m_transformComponent.position, out hit, MaxPositionDistance, NavMesh.AllAreas) == true)
				m_transformComponent.position = hit.position;
		}

		public virtual void StartPathfinder(Vector3 destination)
		{	
			if(m_pathfindingIsActive == false)
			{
				InitializeNavAgentBase();
				StartCoroutine(EnableNavMeshAgent());
				StartCoroutine(CreateDestinationPath(destination));
			}
			else
				Debug.LogWarning(this + " - Pathfinder is already active. Use UpdatePathfinder instead.");
		}

		/// <summary>
		/// This method will activate a coroutine which will send data to 
		/// the Animator component with data which is generated by this component.
		/// </summary>
		public void StartAnimation()
		{
			m_updateAnimationData = true;
			StartCoroutine(UpdateAnimationData());
		}

		/// <summary>
		/// This method will stop the component from sending data, which is generated by this component, to the Animator component.
		/// </summary>
		public void StopAnimation()
		{
			m_updateAnimationData = false;
		}

		/// <summary>
		/// Updates the pathfinderBase with a new destination which it will create a new path and move towards.
		/// This method can only be called on when the pathfinder is already active. Is the component not active (disabled) then
		/// this method will be ignored.
		/// </summary>
		/// <param name="destination">The new current destination.</param>
		public virtual void UpdatePathfinder(Vector3 destination)
		{	
			if(m_pathfindingIsActive == true)
				StartCoroutine(CreateDestinationPath(destination));
		}

		/// <summary>
		/// Stops the pathfinder from moving and the pathfinder is disabled.
		/// </summary>
		public void StopPathfinder()
		{
			if(m_pathfindingIsActive == true)
			{
				if(NavAgent.isOnNavMesh == true)
					NavAgent.Stop();

				m_pathfindingIsActive = false;
				StartCoroutine(EnableNavMeshObstacle());
				StopAnimation();
			}
			else
				Debug.LogWarning(this + " - Pathfinder is already inactive.");
		}

		/// <summary>
		/// Updates the Animator object with data which 
		/// is generated by the component.
		/// </summary>
		private IEnumerator UpdateAnimationData()
		{
			if(NavAgent != null && AnimatorObject != null && string.Equals(MovementParam, string.Empty) == false)
			{
				while(m_pathfindingIsActive == true)
				{
					yield return new WaitForEndOfFrame();
					float animationMovementValue = 0.0f;
					if(m_updateAnimationData == true)
						animationMovementValue = NavAgent.velocity.sqrMagnitude;

					AnimatorObject.SetFloat(MovementParam, animationMovementValue);
				}
			}
		}

		/// <summary>
		/// Coroutine to create a new destination path.
		/// </summary>
		/// <param name="destination">The new destination.</param>
		private IEnumerator CreateDestinationPath(Vector3 destination)
		{
			m_pathfindingIsActive = false;
			while(m_pathfindingIsActive == false)
			{
				yield return new WaitForEndOfFrame();
				if(NavAgent.isOnNavMesh == true)
					m_pathfindingIsActive = NavAgent.SetDestination(destination);
				else
				{
					m_pathfindingIsActive = false;
					SetPositionOnNavMesh();
				}
			}

			StartAnimation();
		}

		/// <summary>
		/// Enables the NavMeshAgent component.
		/// Do note, that the coroutine will have to disable the NavMeshObstacle
		/// before it is able to enable the NavMeshAgent component.
		/// </summary>
		private IEnumerator EnableNavMeshAgent()
		{
			while(NavAgent.isActiveAndEnabled == false)
			{
				yield return new WaitForEndOfFrame();
				NavObstacle.enabled = false;
				if(NavObstacle.isActiveAndEnabled == false)
					NavAgent.enabled = true;
			}
		}

		/// <summary>
		/// Enables the NavMeshObstacle component.
		/// Do note, that the coroutine will have to disable the NavMeshAgent
		/// before it is able to enable the NavMeshObstacle component.
		/// </summary>
		private IEnumerator EnableNavMeshObstacle()
		{
			while(NavObstacle.isActiveAndEnabled == false)
			{
				yield return new WaitForEndOfFrame();
				NavAgent.enabled = false;
				if(NavAgent.isActiveAndEnabled == false)
					NavObstacle.enabled = true;
			}
		}
	}
}
